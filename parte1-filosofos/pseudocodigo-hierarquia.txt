================================================================================
JANTAR DOS FILÓSOFOS - SOLUÇÃO COM HIERARQUIA DE RECURSOS
================================================================================

DESCRIÇÃO:
  Protocolo que ELIMINA DEADLOCK ao impor ordem global de aquisição de garfos.
  Cada filósofo pega primeiro o garfo de MENOR índice, depois o de MAIOR índice,
  quebrando a condição de espera circular.

================================================================================

CONFIGURAÇÃO:
  N = 5 filósofos (numerados de 0 a 4)
  5 garfos (numerados de 0 a 4)
  
  Mesma disposição circular, mas com ESTRATÉGIA DIFERENTE de aquisição.

================================================================================

ESTRATÉGIA - HIERARQUIA DE RECURSOS:

  REGRA FUNDAMENTAL: Sempre adquirir recurso de MENOR ID antes do MAIOR ID

  Para cada filósofo i:
    garfo_esquerda = i
    garfo_direita = (i + 1) mod N
    
    primeiro_garfo = min(garfo_esquerda, garfo_direita)
    segundo_garfo = max(garfo_esquerda, garfo_direita)
    
  Ordem de aquisição: SEMPRE primeiro_garfo → segundo_garfo

================================================================================

ANÁLISE DOS GARFOS POR FILÓSOFO:

  Filósofo 0: esquerda=0, direita=1 → pega 0 depois 1
  Filósofo 1: esquerda=1, direita=2 → pega 1 depois 2
  Filósofo 2: esquerda=2, direita=3 → pega 2 depois 3
  Filósofo 3: esquerda=3, direita=4 → pega 3 depois 4
  Filósofo 4: esquerda=4, direita=0 → pega 0 depois 4 ← QUEBRA O CICLO!

  OBSERVAÇÃO CRÍTICA:
  Filósofo 4 pega garfo 0 ANTES de garfo 4 (ordem inversa à "natural")
  Isso impede o ciclo circular!

================================================================================

ESTRUTURAS DE DADOS:
  Garfo[0..N-1]: semáforo binário (mutex) para cada garfo
  Estado[0..N-1]: estado atual de cada filósofo

================================================================================

PSEUDOCÓDIGO - HIERARQUIA DE RECURSOS:

Para cada Filósofo i (de 0 a N-1) em paralelo:
  
  // Calcula índices dos garfos adjacentes
  garfo_esq ← i
  garfo_dir ← (i + 1) mod N
  
  // HIERARQUIA: sempre menor índice primeiro!
  primeiro ← min(garfo_esq, garfo_dir)
  segundo ← max(garfo_esq, garfo_dir)
  
  Loop infinito:
    
    // FASE 1: PENSAR
    Estado[i] ← PENSANDO
    Exibir("Filósofo", i, "está pensando")
    Pensar()
    
    // FASE 2: FICAR COM FOME
    Estado[i] ← COM_FOME
    Exibir("Filósofo", i, "está com fome")
    
    // FASE 3: ADQUIRIR GARFOS NA ORDEM CORRETA
    Exibir("Filósofo", i, "tentando pegar garfo", primeiro, "(menor ID)")
    Adquirir(Garfo[primeiro])
    Exibir("Filósofo", i, "pegou garfo", primeiro)
    
    Exibir("Filósofo", i, "tentando pegar garfo", segundo, "(maior ID)")
    Adquirir(Garfo[segundo])
    Exibir("Filósofo", i, "pegou garfo", segundo)
    
    // FASE 4: COMER
    Estado[i] ← COMENDO
    Exibir("Filósofo", i, "está comendo com garfos", primeiro, "e", segundo)
    Comer()
    
    // FASE 5: LIBERAR GARFOS (ordem inversa à aquisição)
    Liberar(Garfo[segundo])
    Exibir("Filósofo", i, "liberou garfo", segundo)
    
    Liberar(Garfo[primeiro])
    Exibir("Filósofo", i, "liberou garfo", primeiro)
    
    Estado[i] ← PENSANDO

  Fim Loop

Fim Para

================================================================================

EXEMPLO DE EXECUÇÃO (sem deadlock):

Cenário: Todos os filósofos ficam com fome simultaneamente

Tempo | Filósofo 0 | Filósofo 1 | Filósofo 2 | Filósofo 3 | Filósofo 4
------|------------|------------|------------|------------|-------------
t0    | Pega G0    | Tenta G1   | Tenta G2   | Tenta G3   | Tenta G0
t1    | Pega G1    | (aguarda)  | (aguarda)  | (aguarda)  | (aguarda G0)
t2    | COME       | (aguarda)  | (aguarda)  | (aguarda)  | (aguarda G0)
t3    | Libera G1  | (aguarda)  | (aguarda)  | (aguarda)  | (aguarda G0)
t4    | Libera G0  | (aguarda)  | (aguarda)  | (aguarda)  | Pega G0
t5    | Pensa      | Pega G1   | (aguarda)  | (aguarda)  | Pega G4
t6    | ...        | Pega G2    | (aguarda)  | (aguarda)  | COME
t7    | ...        | COME       | (aguarda)  | (aguarda)  | ...

Resultado: Sistema PROGRIDE! Filósofos comem sequencialmente, sem travamento.

================================================================================

POR QUE NÃO HÁ DEADLOCK?

ANÁLISE DO GRAFO DE ESPERA:

Sem hierarquia (protocolo ingênuo):
  F0 → G1 → F1 → G2 → F2 → G3 → F3 → G4 → F4 → G0 → F0
                                              ↑______|
                                                CICLO!

Com hierarquia:
  F0 possui G0 → aguarda G1
  F1 aguarda G1 (não possui nada ainda)
  F2 aguarda G2 (não possui nada ainda)
  F3 aguarda G3 (não possui nada ainda)
  F4 aguarda G0 (não possui nada ainda) ← Não possui G4!
  
  Grafo é ACÍCLICO (árvore/floresta), sem ciclos!

ORDEM PARCIAL IMPOSTA:
  G0 < G1 < G2 < G3 < G4
  
  Todos seguem: adquirir menor antes de maior
  Logo: impossível ter F4 com G4 esperando G0 enquanto F0 tem G0 esperando G1
  
  Matematicamente: ordem parcial garante ausência de ciclos

================================================================================

ANÁLISE DAS CONDIÇÕES DE COFFMAN (3/4 PRESENTES):

1. EXCLUSÃO MÚTUA:
   PRESENTE - Garfo usado por apenas 1 filósofo por vez
   → Necessário para garantir uso exclusivo

2. MANTER-E-ESPERAR:
    PRESENTE - Filósofo mantém primeiro garfo enquanto aguarda segundo
   → Ainda ocorre, mas não causa problema sem ciclo

3. NÃO PREEMPÇÃO:
   PRESENTE - Garfo não pode ser tirado à força
   → Mantém semântica do problema

4. ESPERA CIRCULAR:
   ELIMINADA - Ordem global impede ciclo de espera!
   → Hierarquia quebra esta condição

CONCLUSÃO: 3/4 condições → DEADLOCK IMPOSSÍVEL! 

================================================================================

GARANTIAS DA SOLUÇÃO:

AUSÊNCIA DE DEADLOCK (Deadlock-Free):
Ordem global garante grafo acíclico de dependências

PROGRESSO DO SISTEMA (Liveness):
Sempre haverá pelo menos 1 filósofo que pode comer
(aquele esperando o garfo de menor índice livre)

JUSTIÇA (Fairness) - CONDICIONAL:
Se semáforos forem FIFO (justos), filósofos não sofrem starvation
Cada filósofo eventualmente consegue comer

LIMITAÇÃO:
Reduz paralelismo: apenas alguns filósofos comem simultaneamente
Trade-off aceitável para garantir correção

================================================================================

COMPARAÇÃO PROTOCOLO INGÊNUO vs HIERARQUIA:

Aspecto              | Ingênuo          | Hierarquia
---------------------|------------------|---------------------------
Deadlock             | Possível       | Impossível
Complexidade         | Simples          | Simples (1 linha a mais!)
Paralelismo          | Alto (se não travar) | Moderado
Starvation           | Possível         | Evitável (com semáforo FIFO)
Implementação        | Intuitiva        | Requer planejamento
Garantia de correção | Nenhuma          | Matemática (ordem parcial)

================================================================================

PSEUDOCÓDIGO ALTERNATIVO (mais compacto):

Para cada Filósofo i:
  primeiro ← min(i, (i+1) mod N)
  segundo ← max(i, (i+1) mod N)
  
  Loop:
    Pensar()
    Adquirir(Garfo[primeiro])
    Adquirir(Garfo[segundo])
    Comer()
    Liberar(Garfo[segundo])
    Liberar(Garfo[primeiro])

// Simples, elegante e SEM DEADLOCK!

================================================================================